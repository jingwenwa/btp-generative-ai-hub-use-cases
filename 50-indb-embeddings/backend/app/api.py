import os
import configparser

from datetime import datetime
from flask import Flask, request, jsonify
from flask_cors import CORS
from hana_ml import dataframe

import math
import pandas as pd
import numpy as np

def nan_to_null(df):
    """Convert all NaN or NaT in a DataFrame to None for JSON serialization."""
    return df.replace({np.nan: None, pd.NaT: None})

# Check if the application is running on Cloud Foundry
if 'VCAP_APPLICATION' in os.environ:
    from app.utilities_hana import kmeans_and_tsne  # works in CF
    
    # Running on Cloud Foundry, use environment variables
    hanaURL = os.getenv('DB_ADDRESS')
    hanaPort = os.getenv('DB_PORT')
    hanaUser = os.getenv('DB_USER')
    hanaPW = os.getenv('DB_PASSWORD')
else:
    from utilities_hana import kmeans_and_tsne  # works in local machine
    
    # Not running on Cloud Foundry, read from config.ini file
    config = configparser.ConfigParser()
    config.read('config.ini')
    hanaURL = config['database']['address']
    hanaPort = config['database']['port']
    hanaUser = config['database']['user']
    hanaPW = config['database']['password']

# Step 1: Establish a connection to SAP HANA
connection = dataframe.ConnectionContext(hanaURL, hanaPort, hanaUser, hanaPW)

app = Flask(__name__)
CORS(app)

# -------------------------------
# Table creation utilities
# -------------------------------
def create_categories_table_if_not_exists():
    create_table_sql = """
        DO BEGIN
            DECLARE table_exists INT;
            
            -- Check and create CATEGORIES table
            SELECT COUNT(*) INTO table_exists
            FROM SYS.TABLES 
            WHERE TABLE_NAME = 'CATEGORIES' AND SCHEMA_NAME = CURRENT_SCHEMA;
            
            IF table_exists = 0 THEN
                CREATE TABLE CATEGORIES (
                    "index" INTEGER,
                    "category_label" NVARCHAR(100),
                    "category_descr" NVARCHAR(5000),
                    "category_embedding" REAL_VECTOR 
                        GENERATED ALWAYS AS VECTOR_EMBEDDING("category_descr", 'DOCUMENT', 'SAP_NEB.20240715')
                );
            END IF;
        END
    """
    cursor = connection.connection.cursor()
    cursor.execute(create_table_sql)
    cursor.close()

def create_project_by_category_table_if_not_exists():
    create_table_sql = """
        DO BEGIN
            DECLARE table_exists INT;
            
            SELECT COUNT(*) INTO table_exists
            FROM SYS.TABLES 
            WHERE TABLE_NAME = 'PROJECT_BY_CATEGORY' AND SCHEMA_NAME = CURRENT_SCHEMA;
            
            IF table_exists = 0 THEN
                CREATE TABLE PROJECT_BY_CATEGORY (
                    PROJECT_ID NVARCHAR(255),
                    CATEGORY_ID INT
                );
            END IF;
        END
    """
    cursor = connection.connection.cursor()
    cursor.execute(create_table_sql)
    cursor.close()  

def create_clustering_table_if_not_exists():
    create_table_sql = """
        DO BEGIN
            DECLARE table_exists INT;
            
            -- CLUSTERING table
            SELECT COUNT(*) INTO table_exists
            FROM SYS.TABLES 
            WHERE TABLE_NAME = 'CLUSTERING' AND SCHEMA_NAME = CURRENT_SCHEMA;
            
            IF table_exists = 0 THEN
                CREATE TABLE CLUSTERING (
                    PROJECT_NUMBER NVARCHAR(255),
                    x DOUBLE,
                    y DOUBLE,
                    CLUSTER_ID INT
                );
            END IF;
            
            -- CLUSTERING_DATA table
            SELECT COUNT(*) INTO table_exists
            FROM SYS.TABLES 
            WHERE TABLE_NAME = 'CLUSTERING_DATA' AND SCHEMA_NAME = CURRENT_SCHEMA;
            
            IF table_exists = 0 THEN
                CREATE TABLE CLUSTERING_DATA (
                    CLUSTER_ID INT,
                    CLUSTER_DESCRIPTION NVARCHAR(255),
                    EMBEDDING REAL_VECTOR GENERATED ALWAYS AS VECTOR_EMBEDDING(CLUSTER_DESCRIPTION, 'DOCUMENT', 'SAP_NEB.20240715')
                );
            END IF;
        END
    """
    cursor = connection.connection.cursor()
    cursor.execute(create_table_sql)
    cursor.close()  

def create_table_if_not_exists(schema_name, table_name):
    create_table_sql = f"""
        DO BEGIN
            DECLARE table_exists INT;
            SELECT COUNT(*) INTO table_exists
            FROM SYS.TABLES 
            WHERE TABLE_NAME = '{table_name.upper()}' AND SCHEMA_NAME = '{schema_name.upper()}';
            
            IF table_exists = 0 THEN
                CREATE TABLE {schema_name}.{table_name} (
                    TEXT_ID INT GENERATED BY DEFAULT AS IDENTITY,
                    TEXT NVARCHAR(5000),
                    EMBEDDING REAL_VECTOR GENERATED ALWAYS AS VECTOR_EMBEDDING(TEXT, 'DOCUMENT', 'SAP_NEB.20240715')
                );
            END IF;
        END
    """
    cursor = connection.connection.cursor()
    cursor.execute(create_table_sql)
    cursor.close()  

# -------------------------------
# Flask Endpoints
# -------------------------------
@app.route('/update_categories_and_projects', methods=['POST'])
def update_categories_and_projects():
    data = request.get_json()
    categories = data
    
    if not categories:
        return jsonify({"error": "No categories provided"}), 400
    
    cursor = connection.connection.cursor()
    
    create_categories_table_if_not_exists()
    cursor.execute("TRUNCATE TABLE CATEGORIES")
    
    create_project_by_category_table_if_not_exists()
    cursor.execute("TRUNCATE TABLE PROJECT_BY_CATEGORY")
    
    # Insert categories
    for index, (title, description) in enumerate(categories.items()):
        insert_sql = f"""
            INSERT INTO CATEGORIES ("index", "category_label", "category_descr")
            VALUES ({index}, '{title.replace("'", "''")}', '{description.replace("'", "''")}')
        """
        cursor.execute(insert_sql)
    
    categories_df = dataframe.DataFrame(connection, 'SELECT * FROM CATEGORIES')
    advisories_df = dataframe.DataFrame(connection, 'SELECT "RULE_ID", "TOPIC" FROM MHA_ADVISORIES4')
    
    # Match advisories to categories using COSINE similarity
    for advisory in advisories_df.collect().to_dict(orient='records'):
        rule_id = advisory['RULE_ID']
        topic = advisory['TOPIC']
        
        if not isinstance(rule_id, int) and not (isinstance(rule_id, str) and rule_id.isdigit()):
            continue
        
        similarities = []
        for category in categories_df.collect().to_dict(orient='records'):
            category_id = category['index']
            category_description = category['category_descr']
            
            similarity_sql = f"""
                SELECT COSINE_SIMILARITY(
                    VECTOR_EMBEDDING('{topic.replace("'", "''")}', 'DOCUMENT', 'SAP_NEB.20240715'),
                    VECTOR_EMBEDDING('{category_description.replace("'", "''")}', 'DOCUMENT', 'SAP_NEB.20240715')
                ) AS similarity
                FROM DUMMY
            """
            similarity_df = dataframe.DataFrame(connection, similarity_sql)
            similarity_results = similarity_df.collect()
            if not similarity_results.empty:
                similarity = similarity_results.iloc[0]['SIMILARITY']
                similarities.append((category_id, similarity))
        
        if similarities:
            most_similar_category = max(similarities, key=lambda x: x[1])
            category_id = most_similar_category[0]
            insert_sql = f"""
                INSERT INTO PROJECT_BY_CATEGORY ("PROJECT_ID", "CATEGORY_ID")
                VALUES ('{rule_id}', {category_id})
            """
            cursor.execute(insert_sql)
    
    cursor.close()
    return jsonify({"message": "Categories and project categories updated successfully"}), 200

@app.route('/get_all_project_categories', methods=['GET'])
def get_all_project_categories():
    sql_query = """
        SELECT pbc."PROJECT_ID", c."category_label"
        FROM "PROJECT_BY_CATEGORY" pbc
        JOIN "CATEGORIES" c ON pbc."CATEGORY_ID" = c."index"
    """
    hana_df = dataframe.DataFrame(connection, sql_query)
    project_categories = hana_df.collect()
    results = project_categories.to_dict(orient='records')
    return jsonify({"project_categories": results}), 200

@app.route('/get_categories', methods=['GET'])
def get_categories():
    sql_query = 'SELECT "index", "category_label", "category_descr" FROM "CATEGORIES"'
    hana_df = dataframe.DataFrame(connection, sql_query)
    categories = hana_df.collect()
    results = categories.to_dict(orient='records')
    return jsonify(results), 200

@app.route('/get_advisories_by_expert_and_category', methods=['GET'])
def get_advisories_by_expert_and_category():
    expert = request.args.get('expert')
    
    if not expert:
        return jsonify({"error": "Expert is required"}), 400
    
    sql_query = f"""
        SELECT c."category_label" AS category, COUNT(a."RULE_ID") AS projects
        FROM "PROJECT_BY_CATEGORY" pbc
        JOIN "CATEGORIES" c ON pbc."CATEGORY_ID" = c."index"
        JOIN "MHA_ADVISORIES4" a ON pbc."PROJECT_ID" = a."RULE_ID"
        WHERE a."NSMAN_ID" = '{expert.replace("'", "''")}'
        GROUP BY c."category_label"
    """
    hana_df = dataframe.DataFrame(connection, sql_query)
    advisories_by_category = hana_df.collect()
    results = advisories_by_category.to_dict(orient='records')
    return jsonify({"advisories_by_category": results}), 200

@app.route('/compare_text_to_existing', methods=['POST'])
def compare_text_to_existing():
    data = request.get_json()
    schema_name = data.get('schema_name', 'DBUSER')
    query_text = data.get('query_text', '')

    if not query_text:
        return jsonify({"error": "query_text is required"}), 400

    similarities = []

    # Extract NSMAN_ID from query_text
    import re
    nsman_match = re.search(r'ID\s*=\s*(\d+)', query_text, re.IGNORECASE)
    nsman_id = nsman_match.group(1) if nsman_match else None

    if not nsman_id:
        return jsonify({"error": "NSMAN_ID not found in query_text"}), 400

    # Extract LOCATION_NAME from query_text (optional)
    loc_match = re.search(r'at (.+)', query_text, re.IGNORECASE)
    location_name = loc_match.group(1).strip() if loc_match else None

    # Case 1: LOCATION_NAME specified → fetch top 3 latest slots
    if location_name:
        slot_query = f"""
            SELECT "LOCATION_NAME", "SLOT_DATE", "SLOT_TIME"
            FROM {schema_name}.BOOKINGS_AVAILABILITY
            WHERE "LOCATION_NAME" = '{location_name}'
            ORDER BY "SLOT_DATE" DESC, "SLOT_TIME" DESC
            LIMIT 3
        """
        slot_df = dataframe.DataFrame(connection, slot_query)
        slots = slot_df.collect().to_dict(orient='records')

        solution_vals = [
            f"{slot['LOCATION_NAME']} | {slot['SLOT_DATE']} | {slot['SLOT_TIME']}" 
            for slot in slots
        ]
        similarities.append({
            "NSMAN_ID": nsman_id,
            "SIMILARITY": "1",
            "SOLUTION": solution_vals[0] if len(solution_vals) > 0 else None,
            "SOLUTION_TWO": solution_vals[1] if len(solution_vals) > 1 else None,
            "SOLUTION_THREE": solution_vals[2] if len(solution_vals) > 2 else None,
        })

    # Case 2: No LOCATION_NAME → fetch top 3 solutions from MHA_ADVISORIES4
    else:
        sql_query = f"""
            SELECT "SOLUTION",
                   "SOLUTION_TWO",
                   "SOLUTION_THREE"
            FROM {schema_name}.MHA_ADVISORIES4
            WHERE "NSMAN_ID" = '{nsman_id}'
            LIMIT 3
        """
        hana_df = dataframe.DataFrame(connection, sql_query)
        solutions = hana_df.collect().to_dict(orient='records')
        for sol in solutions:
            similarities.append({
                "NSMAN_ID": nsman_id,
                "SIMILARITY": "1",
                "SOLUTION": sol["SOLUTION"],
                "SOLUTION_TWO": sol["SOLUTION_TWO"],
                "SOLUTION_THREE": sol["SOLUTION_THREE"]
            })

    return jsonify({"similarities": similarities}), 200


@app.route('/get_project_details', methods=['GET'])
def get_project_details():
    schema_name = request.args.get('schema_name', 'DBUSER')
    rule_id = request.args.get('project_number')
    
    if not rule_id:
        return jsonify({"error": "Project number is required"}), 400
    
    sql_query = f"""
        SELECT 
            a."index" AS advisories_index,
            a."NSMAN_ID",
            a."BOOKING_ID",
            a."START_TIME",
            a."RULE_ID",
            a."RULE_TYPE",
            a."TOPIC",
            a."SOLUTION",
            c."COMMENT",
            c."COMMENT_DATE",
            c."index" AS comments_index
        FROM {schema_name}.MHA_ADVISORIES4 a
        LEFT JOIN {schema_name}.MHA_COMMENTS4 c
        ON a."NSMAN_ID" = c."NSMAN_ID"
        WHERE a."RULE_ID" = '{rule_id}'
    """
    hana_df = dataframe.DataFrame(connection, sql_query)
    project_details = hana_df.collect()
    results = project_details.to_dict(orient='records')
    return jsonify({"project_details": results}), 200

@app.route('/get_all_projects', methods=['GET'])
def get_all_projects():
    schema_name = request.args.get('schema_name', 'DBUSER')
    
    sql_query = f"""
        SELECT * FROM (
            SELECT 
                a."index" AS advisories_index,
                a."NSMAN_ID",
                a."BOOKING_ID",
                a."START_TIME",
                a."RULE_ID",
                a."RULE_TYPE",
                a."TOPIC",
                a."SOLUTION",
                c."COMMENT",
                c."COMMENT_DATE",
                c."index" AS comments_index,
                ROW_NUMBER() OVER (PARTITION BY a."RULE_ID" ORDER BY a."index") AS row_num
            FROM {schema_name}.MHA_ADVISORIES4 a
            LEFT JOIN {schema_name}.MHA_COMMENTS4 c
            ON a."NSMAN_ID" = c."NSMAN_ID"
        ) subquery
        WHERE row_num = 1
    """
    hana_df = dataframe.DataFrame(connection, sql_query)
    all_projects_df = hana_df.collect()
    all_projects_df = nan_to_null(all_projects_df)
    results = all_projects_df.to_dict(orient='records')
    return jsonify({"all_projects": results}), 200

# -------------------------------
# Root Health Check
# -------------------------------
@app.route('/', methods=['GET'])
def root():
    return 'Embeddings Base API: Health Check Successful.', 200

def create_app():
    return app

if __name__ == "__main__":
    port = int(os.environ.get("PORT", 3000))
    app.run(host="0.0.0.0", port=port, debug=False)
